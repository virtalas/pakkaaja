<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fi"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HuffmanCoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pakkaaja</a> &gt; <a href="index.source.html" class="el_package">main.java.huffman</a> &gt; <span class="el_source">HuffmanCoder.java</span></div><h1>HuffmanCoder.java</h1><pre class="source lang-java linenums">package main.java.huffman;

import main.java.io.FileInput;
import main.java.io.FileOutput;
import main.java.structures.MinHeap;

/**
 * Implements the Huffman coding and writes the compressed file.
 */
public class HuffmanCoder {

    /**
     * An integer array where the index represents the character/byte, and the
     * value represents the frequency of the character/byte.
     */
    private final int[] byteFrequencies;
    
    private final int alphabetSize;

    /**
     * A string array where the index represents the character/byte, and the
     * value represents the huffman code of the character/byte.
     */
    public String[] codes;

    /**
     * Initializes byteFrequencies and codes.
     *
     * @param bytes array of character/byte frequencies
     * @param alphabetSize size of the alphabet, or how many unique characters
     * there can be.
     */
<span class="fc" id="L33">    public HuffmanCoder(int[] bytes, int alphabetSize) {</span>
<span class="fc" id="L34">        this.byteFrequencies = bytes;</span>
<span class="fc" id="L35">        this.codes = new String[alphabetSize];</span>
<span class="fc" id="L36">        this.alphabetSize = alphabetSize;</span>
<span class="fc" id="L37">    }</span>

    /**
     * Run the Huffman coding algorithm and write the compressed file. Writes
     * the Huffman tree first and then the compressed content.
     */
    public void compress(FileInput in, FileOutput out) {
<span class="fc" id="L44">        initEndOfFileCharacterFrequency();</span>
<span class="fc" id="L45">        HuffmanTree root = buildTree();</span>
<span class="fc" id="L46">        buildCodeList(root, new StringBuffer());</span>

<span class="fc" id="L48">        writeTree(out, root);</span>
<span class="fc" id="L49">        writeCompressedContent(in, out);</span>
<span class="fc" id="L50">    }</span>

    /**
     * 0 = NUL, used as the end of file character. Frequency is once at the end
     * of the file.
     */
    public void initEndOfFileCharacterFrequency() {
<span class="fc" id="L57">        byteFrequencies[0] = 1;</span>
<span class="fc" id="L58">    }</span>

    /**
     * Reads the source file and writes the compressed destination file using
     * huffman codes.
     */
    public void writeCompressedContent(FileInput in, FileOutput out) {
<span class="fc" id="L65">        int readByte = in.readByte();</span>

<span class="fc bfc" id="L67" title="All 2 branches covered.">        while (readByte != -1) {</span>
<span class="fc" id="L68">            out.writeBits(codes[readByte]);</span>
<span class="fc" id="L69">            readByte = in.readByte();</span>
        }

<span class="fc" id="L72">        out.writeBits(codes[0]); // Write the end of file character at the end.</span>
<span class="fc" id="L73">        in.close();</span>
<span class="fc" id="L74">        out.close();</span>
<span class="fc" id="L75">    }</span>

    /**
     * First the structure of the tree is written, ending with the output at the
     * beginning of the next byte. Then the leaf values are written, one value
     * per byte.
     *
     * @param out FileOutput for the bits.
     * @param root Root of the tree to be written.
     */
    public void writeTree(FileOutput out, HuffmanTree root) {
<span class="fc" id="L86">        writeTreeStructure(out, root);</span>
<span class="fc" id="L87">        out.advanceToNextByte();</span>
<span class="fc" id="L88">        writeTreeLeaves(out, root);</span>
<span class="fc" id="L89">    }</span>

    /**
     * Traverses the tree in pre-order and writes 0 for leaf, 1 for internal
     * node.
     *
     * @param out FileOutput for the bits.
     * @param tree subtree to be written and traversed
     */
    public void writeTreeStructure(FileOutput out, HuffmanTree tree) {
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (tree instanceof HuffmanLeaf) {</span>
<span class="fc" id="L100">            out.writeBit(0);</span>
        } else {
<span class="fc" id="L102">            out.writeBit(1);</span>
<span class="fc" id="L103">            HuffmanInternalNode node = (HuffmanInternalNode) tree;</span>
<span class="fc" id="L104">            writeTreeStructure(out, node.left);</span>
<span class="fc" id="L105">            writeTreeStructure(out, node.right);</span>
        }
<span class="fc" id="L107">    }</span>

    /**
     * Traverses the tree in pre-order and writes leaf values, one value/leaf
     * per byte.
     *
     * @param out FileOutput for the bytes.
     * @param tree subtree to be written and traversed
     */
    public void writeTreeLeaves(FileOutput out, HuffmanTree tree) {
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (tree instanceof HuffmanLeaf) {</span>
<span class="fc" id="L118">            HuffmanLeaf leaf = (HuffmanLeaf) tree;</span>
<span class="fc" id="L119">            out.writeByte(leaf.value);</span>
<span class="fc" id="L120">        } else {</span>
<span class="fc" id="L121">            HuffmanInternalNode node = (HuffmanInternalNode) tree;</span>
<span class="fc" id="L122">            writeTreeLeaves(out, node.left);</span>
<span class="fc" id="L123">            writeTreeLeaves(out, node.right);</span>
        }
<span class="fc" id="L125">    }</span>

    /**
     * Builds the Huffman tree by combining the least frequent trees until the
     * tree is complete.
     *
     * @return the root of the tree
     */
    public HuffmanTree buildTree() {
<span class="fc" id="L134">        MinHeap trees = new MinHeap(alphabetSize);</span>
        // Initially, there are only leaves, one for each non-empty character
<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (int i = 0; i &lt; byteFrequencies.length; i++) {</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (byteFrequencies[i] &gt; 0) {</span>
<span class="fc" id="L138">                trees.insert(new HuffmanLeaf(byteFrequencies[i], (char) i));</span>
            }
        }

        // Loop until there is only one tree left
<span class="fc bfc" id="L143" title="All 2 branches covered.">        while (trees.size() &gt; 1) {</span>
            // two trees with least frequency
<span class="fc" id="L145">            HuffmanTree a = trees.delMin();</span>
<span class="fc" id="L146">            HuffmanTree b = trees.delMin();</span>

            // Put into new node and re-insert into queue
<span class="fc" id="L149">            trees.insert(new HuffmanInternalNode(a, b));</span>
<span class="fc" id="L150">        }</span>
<span class="fc" id="L151">        return trees.min();</span>
    }

    /**
     * Builds an array of characters and their corresponding Huffman codes
     *
     * @param tree complete Huffman tree
     * @param prefix initializes the prefix/code
     */
    public void buildCodeList(HuffmanTree tree, StringBuffer prefix) {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (tree instanceof HuffmanLeaf) {</span>
<span class="fc" id="L162">            HuffmanLeaf leaf = (HuffmanLeaf) tree;</span>

<span class="fc" id="L164">            System.out.println(leaf.value + &quot;\t&quot; + leaf.frequency + &quot;\t&quot; + prefix);</span>

<span class="fc" id="L166">            codes[leaf.value] = prefix.toString();</span>

<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        } else if (tree instanceof HuffmanInternalNode) {</span>
<span class="fc" id="L169">            HuffmanInternalNode node = (HuffmanInternalNode) tree;</span>

            // Traverse left
<span class="fc" id="L172">            prefix.append('0');</span>
<span class="fc" id="L173">            buildCodeList(node.left, prefix);</span>
<span class="fc" id="L174">            prefix.deleteCharAt(prefix.length() - 1);</span>

            // Traverse right
<span class="fc" id="L177">            prefix.append('1');</span>
<span class="fc" id="L178">            buildCodeList(node.right, prefix);</span>
<span class="fc" id="L179">            prefix.deleteCharAt(prefix.length() - 1);</span>
        }
<span class="fc" id="L181">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>