<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fi"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HuffmanCoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pakkaaja</a> &gt; <a href="index.source.html" class="el_package">main.java.huffman</a> &gt; <span class="el_source">HuffmanCoder.java</span></div><h1>HuffmanCoder.java</h1><pre class="source lang-java linenums">package main.java.huffman;

import java.util.PriorityQueue;
import main.java.io.FileInput;
import main.java.io.FileOutput;

/**
 * Implements the Huffman coding and writes the compressed file.
 */
public class HuffmanCoder {

    /**
     * An integer array where the index represents the character/byte, and the
     * value represents the frequency of the character/byte.
     */
    private final int[] byteFrequencies;

    /**
     * A string array where the index represents the character/byte, and the
     * value represents the huffman code of the character/byte.
     */
    public String[] codes;

    /**
     * Initializes byteFrequencies and codes.
     *
     * @param bytes array of character/byte frequencies
     * @param alphabetSize size of the alphabet, or how many unique characters
     * there can be.
     */
<span class="fc" id="L31">    public HuffmanCoder(int[] bytes, int alphabetSize) {</span>
<span class="fc" id="L32">        this.byteFrequencies = bytes;</span>
<span class="fc" id="L33">        this.codes = new String[alphabetSize];</span>
<span class="fc" id="L34">    }</span>

    /**
     * Run the Huffman coding algorithm and write the compressed file. Writes
     * the Huffman tree first and then the compressed content.
     */
    public void compress(FileInput in, FileOutput out) {
<span class="fc" id="L41">        HuffmanTree root = buildTree();</span>
<span class="fc" id="L42">        buildCodeList(root, new StringBuffer());</span>

<span class="fc" id="L44">        writeTree(out, root);</span>
<span class="fc" id="L45">        writeCompressedContent(in, out);</span>
<span class="fc" id="L46">        out.close();</span>
<span class="fc" id="L47">    }</span>

    /**
     * Reads the source file and writes the compressed destination file using
     * huffman codes.
     */
    public void writeCompressedContent(FileInput in, FileOutput out) {
<span class="fc" id="L54">        int readByte = in.readByte();</span>

<span class="fc bfc" id="L56" title="All 2 branches covered.">        while (readByte != -1) {</span>
<span class="fc" id="L57">            out.writeBits(codes[readByte]);</span>
<span class="fc" id="L58">            readByte = in.readByte();</span>
        }
<span class="fc" id="L60">        in.close();</span>
<span class="fc" id="L61">    }</span>

    /**
     * First the structure of the tree is written, ending with the output at the
     * beginning of the next byte. Then the leaf values are written, one value
     * per byte.
     *
     * @param out FileOutput for the bits.
     * @param root Root of the tree to be written.
     */
    public void writeTree(FileOutput out, HuffmanTree root) {
<span class="fc" id="L72">        writeTreeStructure(out, root);</span>
<span class="fc" id="L73">        out.advanceToNextByte();</span>
<span class="fc" id="L74">        writeTreeLeaves(out, root);</span>
<span class="fc" id="L75">    }</span>

    /**
     * Traverses the tree in pre-order and writes 0 for leaf, 1 for internal
     * node.
     *
     * @param out FileOutput for the bits.
     * @param tree subtree to be written and traversed
     */
    public void writeTreeStructure(FileOutput out, HuffmanTree tree) {
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (tree instanceof HuffmanLeaf) {</span>
<span class="fc" id="L86">            out.writeBit(0);</span>
        } else {
<span class="fc" id="L88">            out.writeBit(1);</span>
<span class="fc" id="L89">            HuffmanInternalNode node = (HuffmanInternalNode) tree;</span>
<span class="fc" id="L90">            writeTreeStructure(out, node.left);</span>
<span class="fc" id="L91">            writeTreeStructure(out, node.right);</span>
        }
<span class="fc" id="L93">    }</span>

    /**
     * Traverses the tree in pre-order and writes leaf values, one value/leaf
     * per byte.
     *
     * @param out FileOutput for the bytes.
     * @param tree subtree to be written and traversed
     */
    public void writeTreeLeaves(FileOutput out, HuffmanTree tree) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (tree instanceof HuffmanLeaf) {</span>
<span class="fc" id="L104">            HuffmanLeaf leaf = (HuffmanLeaf) tree;</span>
<span class="fc" id="L105">            out.writeByte(leaf.value);</span>
<span class="fc" id="L106">        } else {</span>
<span class="fc" id="L107">            HuffmanInternalNode node = (HuffmanInternalNode) tree;</span>
<span class="fc" id="L108">            writeTreeLeaves(out, node.left);</span>
<span class="fc" id="L109">            writeTreeLeaves(out, node.right);</span>
        }
<span class="fc" id="L111">    }</span>

    /**
     * Builds the Huffman tree by combining the least frequent trees until the
     * tree is complete.
     *
     * @return the root of the tree
     */
    public HuffmanTree buildTree() {
<span class="fc" id="L120">        PriorityQueue&lt;HuffmanTree&gt; trees = new PriorityQueue&lt;HuffmanTree&gt;();</span>
        // Initially, there are only leaves, one for each non-empty character
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (int i = 0; i &lt; byteFrequencies.length; i++) {</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">            if (byteFrequencies[i] &gt; 0) {</span>
<span class="fc" id="L124">                trees.offer(new HuffmanLeaf(byteFrequencies[i], (char) i));</span>
            }
        }

        // Loop until there is only one tree left
<span class="fc bfc" id="L129" title="All 2 branches covered.">        while (trees.size() &gt; 1) {</span>
            // two trees with least frequency
<span class="fc" id="L131">            HuffmanTree a = trees.poll();</span>
<span class="fc" id="L132">            HuffmanTree b = trees.poll();</span>

            // Put into new node and re-insert into queue
<span class="fc" id="L135">            trees.offer(new HuffmanInternalNode(a, b));</span>
<span class="fc" id="L136">        }</span>
<span class="fc" id="L137">        return trees.poll();</span>
    }

    /**
     * Builds an array of characters and their corresponding Huffman codes
     *
     * @param tree complete Huffman tree
     * @param prefix initializes the prefix/code
     */
    public void buildCodeList(HuffmanTree tree, StringBuffer prefix) {
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (tree instanceof HuffmanLeaf) {</span>
<span class="fc" id="L148">            HuffmanLeaf leaf = (HuffmanLeaf) tree;</span>

<span class="fc" id="L150">            System.out.println(leaf.value + &quot;\t&quot; + leaf.frequency + &quot;\t&quot; + prefix);</span>

<span class="fc" id="L152">            codes[leaf.value] = prefix.toString();</span>

<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        } else if (tree instanceof HuffmanInternalNode) {</span>
<span class="fc" id="L155">            HuffmanInternalNode node = (HuffmanInternalNode) tree;</span>

            // Traverse left
<span class="fc" id="L158">            prefix.append('0');</span>
<span class="fc" id="L159">            buildCodeList(node.left, prefix);</span>
<span class="fc" id="L160">            prefix.deleteCharAt(prefix.length() - 1);</span>

            // Traverse right
<span class="fc" id="L163">            prefix.append('1');</span>
<span class="fc" id="L164">            buildCodeList(node.right, prefix);</span>
<span class="fc" id="L165">            prefix.deleteCharAt(prefix.length() - 1);</span>
        }
<span class="fc" id="L167">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>